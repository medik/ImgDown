#!/usr/bin/env ruby1.9.1
# encoding: utf-8

"""""""
ImageDownloader

Olof Sj√∂din
me@olofsjodin.se

I didn't found any application that did what I wanted it to do, and
I wanted my own application so I created this. That was how ImgDown
was born.
"""""""
IMGDOWN_VERSION = "Imgdown v0.2.1.2"
if Gem::Specification::find_by_name('nokogiri') == false then
	put "Error! Nokogiri is NOT installed. Install nokogiri and try run imgdown again."
	exit
elsif Gem::Specification::find_by_name('trollop') == false then
	put "Error! Trollop is NOT installed. Install trollop and try imgdown again."
	exit
end

require 'uri'
require 'open-uri'
require 'nokogiri'
require 'trollop'

opts = Trollop::options do
	version IMGDOWN_VERSION
	banner <<-EOS
ImgDown is a script that download images from a given webpage.
Usage:
	imgdown [options]

	where the [options] is
EOS
	
	opt :download, "This trigger the download sequence.", :short => 'd', :default => false
	opt :reg_ex, "Use this tag to define a regular expression.", :short => 'r', :type => String, :default => "(.*)" # TODO: How does the regex for this program work.
	opt :link, "Link to the page that you want to download images from.", :short => 'l', :type => String
	opt :destination, "This defines the folder you want to download images to.", :short => 't', :type => String, :default => Dir.pwd
	opt :user_agent, "Use this tag if you want to specify a user-agent.", :short => 's', :type => String, :default => IMGDOWN_VERSION
    	opt :overwrite, "If you want to overwrite existing files with the same name", :short => 'i', :default => false
	opt :extensions, "The fileextensions imgdown will looking for", :short => 'x', :type => :strings, :default => ["jpe?g","png","gif"]
end

Trollop::die :link, "must exist" if opts[:link] == "" || opts[:link] == nil

# Dir["#{downl_path}/*"].each do |fname|
# f_names.push(filen_extract(fname))
# end

# extractFilename(url)
# ------------------
# Extracting filenames
#
# Example:
# http://foo/bar/lols.img => lols.img
# /foo/bar/lols.img => lols.img

def extractFilename(url)
	url =~ /^.*\/(.*)\.(.*)$/
	if url == "" or url == nil then
		return ""
	else
		return "#{$1}.#{$2}"
	end
end

# getHostname(uri)
# ----------------
#
# Extracting hostname
#
# Example:
# http://foo.com/bar => http://foo.com
# https://www.alice.foo/bar => https://www.alice.foo

def getHostname(uri)
	uri =~ /^(https?:\/\/.*[a-z]+\.[a-z]+)\/?.*$/
	return "#{$1}"
end

# doublet?(file_n, dir)
# ---------------------
#
# Checking if a file exists in a directory
#
# Example:
# The Tree
# /
# |--foo1
# |---|---bar1
# |---|---bar2
# |--foo2
# |---|---bar1
# |---|---bar2
# 
# ("bar1", "/foo1") => true
# ("bar1", "/foo2") => true
# ("bar3", "/foo1") => false

def doublet?(file_n, dir)
	f_names = Dir["#{dir}/*"].map { |path| extractFilename(path) }
	doublet = false
	f_names.each do |filename|
		if "#{file_n}" == "#{filename}"
			doublet = true
		end
	end
	return doublet
end

def link_sherlock(url, regexp, user_agent, fileExt) # Search document and substituting loose ends
	_nokogiri_html_img = Nokogiri::HTML(open(url, 'User-Agent' => user_agent)).xpath('.//img/@src').to_a
	_nokogiri_html_a = Nokogiri::HTML(open(url,'User-Agent' => user_agent)).xpath('.//a/@href').to_a
	
	_links_array = _nokogiri_html_img + _nokogiri_html_a
	
	_m_links = []
	
	# Fixing links
	_links_array.each do |link|
		if "#{link}" =~ /#{regexp}/
			case link
			when /^\/[^\/].*\.(#{fileExt})$/
				_m_links.push("#{getHostname(url)}#{link}")
			when /^https?:\/\/.*\.(#{fileExt})$/
				_m_links.push("#{link}")
			when /^[a-zA-Z0-9]+.*\.(#{fileExt})$/
				_m_links.push("#{getHostname(url)}/#{link}")
			when /^\/\/http:\/\/(.*\.(#{fileExt}))$/	# FIXME: Change the regex to a substitution instead.
				_m_links.push("http://#{$1}")
			when /^\/\/(?!https?)(.*\.(#{fileExt}))$/
				_m_links.push("http://#{$1}")
			end
		end
	end
	
	# No matches.
	if _m_links.count == 0
		puts "Zero matches."
	end

	# Return matches.
	return _m_links.uniq
end

def downl_f(file_uri, downl_path, user_agent)
	uri = URI(URI.parse(URI.encode(file_uri)))
	puts "Downloading #{file_uri}..."
	_file_h = open("#{downl_path}/#{extractFilename(file_uri)}", "wb")
	_file_h.write(open(uri.to_s,'User-Agent' => user_agent).read)
	_file_h.close
end


def downl_all(array_w_links, dwl_path, user_agent, ow)
	puts "Downloading..."

	if ow == true then
		puts "Overwrite mode is on, ImgDown will overwrite existing files"
	end
	
	array_w_links.each do |url|
		doubl = doublet?(extractFilename(url), dwl_path)
		if ow or !doubl then
			downl_f(url, dwl_path, user_agent)
		elsif doubl then
			puts "Continue?"
			if yesno("There was already an '#{extractFilename(url)}' in the directory!\n Continue?") then 
				downl_f(url, dwl_path, user_agent)
			else
				puts "Quiting."
				exit
			end
		end
	end
end

def yesno(question)
	puts "#{question} [y/n]"
	    loop do
		begin
		      system("stty raw -echo")
		      str = STDIN.getc
		ensure
		      system("stty -raw echo")
		end

		if str == "Y" || str == "y"
		    return true
		elsif str == "N" || str == "n"
		    return false
		else
		    puts "Please enter [y]es or [n]o."
		end
	    end
end

downl_mode 	= opts[:download]			
downl_path 	= opts[:destination]
regex 		= opts[:reg_ex]
url 		= opts[:link]
user_agent  	= opts[:user_agent]
ow		= opts[:overwrite]
file_extension  = opts[:extensions].join("|")

puts IMGDOWN_VERSION
#puts "Settings:\n download mode: #{downl_mode}\n download path: #{downl_path}\n regex: #{regex}\n user-agent: #{user_agent}\n overwrite: #{ow}"

if downl_mode then
	downl_all(link_sherlock(url, regex, user_agent, file_extension), downl_path, user_agent, ow)

elsif !downl_mode then
    links_a = link_sherlock(url, regex, user_agent, file_extension)
	
    if links_a.count > 0 then 
        links_a.each do |link|
	    	puts "#{link}"
	    end
        dl = yesno("Do you want to download these files to #{downl_path}?")
        if dl then
	        downl_all(link_sherlock(url, regex, user_agent, file_extension), downl_path, user_agent, ow)
        elsif !dl then
            puts "Bye."
        end
    end
end
