#!/usr/bin/env ruby1.9.1
# encoding: utf-8

"""""""
ImageDownloader

Olof Sj√∂din
me@olofsjodin.se

I didn't found any application that did what I wanted it to do, and
I wanted my own application so I created this. That was how ImgDown
was born.

This is what ImgDown do.
	- Getting all <img src='x'> and <a href='x'> (NEW) in a webpage and downloading every single one those you choose with regex.
	- Sort the links with the help of RegEx.
	- Could show all the links BEFORE downloading them. (YEAAAAH)

"""""""
if Gem::Specification::find_by_name('nokogiri') == false then
	put "Error! Nokogiri is NOT installed. Install nokogiri and try run imgdown again."
	exit
elsif Gem::Specification::find_by_name('trollop') == false then
	put "Error! Trollop is NOT installed. Install trollop and try imgdown again."
	exit
end

require 'open-uri'
require 'nokogiri'
require 'trollop'

opts = Trollop::options do
	version "ImgDown v0.2.1"
	banner <<-EOS
ImgDown is a script that download images from a given webpage.
Usage:
	imgdown [options]

	where the [options] is
EOS
	
	opt :download, "This trigger the download sequence.", :short => 'd', :default => false
	opt :reg_ex, "Use this tag to define a regular expression.", :short => 'r', :type => String, :default => "(.*)" # TODO: How does the regex for this program work.
	opt :link, "Link to the page that you want to download images from.", :short => 'l', :type => String
	opt :destination, "This defines the folder you want to download images to.", :short => 't', :type => String, :default => Dir.pwd
	opt :user_agent, "Use this tag if you want to specify a user-agent.", :short => 's', :type => String, :default => "ImgDown v0.2.1"
    	#opt :overwrite, "If you want to overwrite existing files with the same name", :short => 'i', :default => false  FIXME
end

Trollop::die :link, "must exist" if opts[:link] == "" || opts[:link] == nil

# Dir["#{downl_path}/*"].each do |fname|
# f_names.push(filen_extract(fname))
# end

def urlToFilename(url)
	url =~ /^.*\/(.*)\.(.*)$/
	if url == "" or url == nil then
		return ""
	else
		return "#{$1}.#{$2}"
	end
end

def getHostname(uri)
	uri =~ /^(https?:\/\/.*[a-z]+\.[a-z]+)\/?.*$/
	return "#{$1}"
end

def link_sherlock(url, regexp, user_agent) # Search document and substituting loose ends
	_nokogiri_html_img = Nokogiri::HTML(open(url, 'User-Agent' => user_agent)).xpath('.//img/@src').to_a
	_nokogiri_html_a = Nokogiri::HTML(open(url,'User-Agent' => user_agent)).xpath('.//a/@href').to_a
	
	_links_array = _nokogiri_html_img + _nokogiri_html_a
	
	_m_links = []
	
	# Fixing links
	_links_array.each do |link|
		if "#{link}" =~ /#{regexp}/
			case link
			when /^\/[^\/].*\.(jpe?g|png|gif)$/
				_m_links.push("#{getHostname(url)}#{link}")
			when /^https?:\/\/.*\.(jpe?g|png|gif)$/
				_m_links.push("#{link}")
			when /^[a-zA-Z0-9]+.*\.(jpe?g|png|gif)$/
				_m_links.push("#{getHostname(url)}/#{link}")
			when /^\/\/http:\/\/(.*\.(jpe?g|png|gif))$/	# FIXME: Change the regex to a substitution instead.
				_m_links.push("http://#{$1}")
            when /^\/\/(?!https?)(.*\.(jpe?g|png|gif))$/
                _m_links.push("http://#{$1}")
			end
		end
	end
	
	# No matches.
	if _m_links.count == 0
		puts "Zero matches."
	end

	# Return matches.
	return _m_links
end

def downl_f(file_uri, downl_path, user_agent)
	puts "Downloading #{file_uri}..."
	_file_h = open("#{downl_path}/#{urlToFilename(file_uri)}", "wb")
	_file_h.write(open(file_uri,'User-Agent' => user_agent).read)
	_file_h.close
end


def downl_all(array_w_links, dwl_path, user_agent)
	puts "Downloading..."

	f_names = Dir["#{dwl_path}/*"].map { |path| urlToFilename(path) }
	
	array_w_links.each do |url|
		#if opts[:overwrite] == true then
		#	downl_f(url, dwl_path, user_agent)
		#elsif doublet?(urlToFilename(url), f_names) != true then
		#	downl_f(url, dwl_path, user_agent)
		#end FIXME FIXME FIXME
		downl_f(url, dwl_path, user_agent)
	end
end

def doublet?(file_n, cmp_a)
	doublet = false
	cmp_a.each do |link|
		if "#{file_n}" == "#{link}"
			doublet = true
			puts "There was already an '#{file_n}' in the directory!"
		end
	end
	return doublet
end

def yesno
    loop do
        begin
              system("stty raw -echo")
              str = STDIN.getc
        ensure
              system("stty -raw echo")
        end

        if str == "Y" || str == "y"
            return true
        elsif str == "N" || str == "n"
            return false
        else
            puts "Please enter [y]es or [n]o."
        end
    end
end

downl_mode 	= opts[:download]			
downl_path 	= opts[:destination]
regex 		= opts[:reg_ex]
url 		= opts[:link]
user_agent  	= opts[:user_agent]

if downl_mode then
	downl_all(link_sherlock(url, regex, user_agent), downl_path, user_agent)

elsif !downl_mode then
    links_a = link_sherlock(url, regex, user_agent)
	
    if links_a.count > 0 then 
        links_a.each do |link|
	    	puts "#{link}"
	    end
        puts "Do you want to leech these links to #{downl_path}? [y/n]"
        dl = yesno
        if dl then
	        downl_all(link_sherlock(url, regex, user_agent), downl_path, user_agent)
        elsif !dl then
            puts "Good bye"
        end
    end
end
