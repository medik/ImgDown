#!/usr/bin/env ruby
# encoding: utf-8

"""""""
ImgDown, written by Olof <medik> Sj√∂din
Last modified: 2016-05-02

ImgDown is used as image extractor to recursively download matched pattern.
The pattern is a regular expression. 

See https://en.wikipedia.org/wiki/Regular_expression for reference.

Usage:
./imgdown --download --link 'http://foo/bar' --regex '.*catpics\.jpe?g'
"""""""

IMGDOWN_VERSION = "v1.11"
REGEXDICTIONARY = "regexdict.txt"

require 'curb'
require 'uri'
require 'open-uri'
require 'nokogiri'
require 'trollop'
require 'fileutils'

$opts = Trollop::options do
	version "ImgDown #{IMGDOWN_VERSION}"
	banner <<-EOS
ImgDown is used as image extractor to recursively download matched pattern.
The pattern is a regular expression. 

See https://en.wikipedia.org/wiki/Regular_expression for reference.

Example:
./imgdown --download --link 'http://foo/bar' --regex '.*catpics\.jpe?g'

Usage:
./imgdown [options]

Where the options can be the following flags.
EOS
	
	opt :download, "This trigger the download sequence.", :short => 'd', :default => false
	opt :regex, "Use this tag to define a regular expression.", :short => 'r', :type => String, :default => "(.*)" # TODO: How does the regex for this program work.
	opt :link, "Link to the page that you want to download images from.", :short => 'l', :type => String
	opt :destination, "This defines the folder you want to download images to.", :short => 't', :type => String, :default => Dir.pwd
	opt :user_agent, "Use this tag if you want to specify a user-agent.", :short => 's', :type => String, :default => "ImgDown #{IMGDOWN_VERSION}"
	opt :choose_user_agent, "Retrieve a list of saved user agents.", :default => false
    opt :overwrite, "If you want to overwrite existing files with the same name", :short => 'i', :default => false
	opt :extensions, "The fileextensions imgdown will looking for", :short => 'x', :type => :strings, :default => ["jpe?g","png","gif"]
end

Trollop::die :link, "must exist" if $opts[:link] == "" || $opts[:link] == nil

##
# Check if user agent exist in the list of user-agents

def doesUAexist(userAgentList, ua)
	return userAgentList.include? ua
end

##
# Ask what user-agents to use

def askUAFromUser(userAgents)
	system("clear")

	loop do
        begin
        	i = 0
      		puts "\nChoose user agent from this list\n"
    		userAgents.each do |ua|
				puts "#{i+1} #{ua}"
				i += 1
			end
            system("stty raw -echo")
            num = Integer(STDIN.getc)
        ensure
            system("stty -raw echo")
        end

        if num > userAgents.length or num <= 0 then
      		system("clear")
        	puts "Don't mess with me."
        else
        	puts "You choose #{userAgents[num-1]}"
        	return userAgents[num-1]
        end

    end
end


##
# Retrieving saved user-agents from $USER

def getUserAgents(filepath)
	fh = File.open(filepath)
	
	ret = Array.new
	
	fh.each do |line|
		ret.push(line.delete!("\n"))
	end

	fh.close()
	return ret
end

##
# Saving user-agent to user-defined

def saveUserAgent(newUserAgents, filepath)
	fh = File.open(filepath, 'w')
	fh.truncate(0)

	newUserAgents.each do |ua|
		fh.write(ua)
		fh.write("\n")
	end	
	fh.close()
end

##
# Parsing a URL and returns the filename and extension

def extractFilename(url)
	url =~ /^.*\/(.*)\.(.*)$/
	if url == "" or url == nil then
		return ""
	else
		return "#{$1}.#{$2}"
	end
end

##
# Extracts the hostname from a URL

def getHostname(uri)
	uri =~ /^(https?:\/\/([a-zA-Z0-9]+\.)+[a-zA-Z0-9]+)(\/.*)?$/
	return "#{$1}"
end

##
# Checking if a file exists in a directory.
 
def doublet?(file, dir)
        return File.exists?("#{dir}/#{file}")
end

##
# This function searchs a HTML documents after images-urls
# and links that matches specified regular expression and 
# file extension.

def link_sherlock(url, regexp, user_agent, fileExt)
	_nokogiri_html_img = Nokogiri::HTML(
            open(url, 'User-Agent' => user_agent)).xpath('.//img/@src').to_a
	_nokogiri_html_a = Nokogiri::HTML(
            open(url,'User-Agent' => user_agent)).xpath('.//a/@href').to_a
	
	_links_array = _nokogiri_html_img + _nokogiri_html_a
	
	_m_links = []
	
	# Fixing links
	_links_array.each do |link|
		if "#{link}" =~ /#{regexp}/
			case link
			# /foo/bar/img
			when /^\/[^\/].*\.(#{fileExt})$/
				_m_links.push("#{getHostname(url)}#{link}")
			# https?://foo.bar [..] .fileext
			when /^https?:\/\/.*\.(#{fileExt})$/
				_m_links.push("#{link}")
			# abcd01234/foo [..] .fileext
			when /^[a-zA-Z0-9]+.*\/.*\.(#{fileExt})$/
				_m_links.push("#{getHostname(url)}/#{link}")
			when /^\/\/http:\/\/(.*\.(#{fileExt}))$/
				_m_links.push("http://#{$1}")
			when /^\/\/(?!https?)(.*\.(#{fileExt}))$/
				_m_links.push("http://#{$1}")
                        when /.*#{fileExt}$/
                            _m_links.push("#{url}/#{link}")
			end
		end
	end
	
	# No matches.
	if _m_links.count == 0
		puts "Zero matches."
	end

	# Return matches.
	return _m_links.uniq
end

##
# Downloads specified file to downl_path. User-agent must be specified.

def downl_f(file_uri, downl_path, user_agent)
	uri = URI(URI.parse(URI.encode(file_uri)))
	puts "Downloading #{file_uri} to #{downl_path}/#{extractFilename(file_uri)}..."
	_file_h = open("#{downl_path}/#{extractFilename(file_uri)}", "wb")
	curl = Curl::Easy.new(uri.to_s)
	curl.perform
	_file_h.write(curl.body_str)
	_file_h.close

end

##
# This function will download multiple files specified in a array of links.
# It will be downloaded to dwl_path and user-agent must be specifed. That
# includes if it should overwrite or not.

def downl_all(array_w_links, dwl_path, user_agent, overwrite)
    # There should be a check whether the directory exist or not. TODO
    if not File.directory?(dwl_path) then
        puts "Path is not valid! Trying to create the path."
        FileUtils::mkdir_p dwl_path
    end
    
    if overwrite then
            puts "Overwrite mode is on, ImgDown will overwrite existing files"
    end
    
    array_w_links.each do |url|
            doublet_exist = doublet?(extractFilename(url), dwl_path)
            if overwrite or !doublet_exist then
                    downl_f(url, dwl_path, user_agent)
            elsif doublet_exist then
                    if yesno("There was already an "\
                                "'#{extractFilename(url)}' "\
                                " in the directory!\n Continue?") then 
                            downl_f(url, dwl_path, user_agent)
                    else
                            puts "Quiting."
                            exit
                    end
            end
    end
end

##
# Will ask the user yes or no with a specified question. If user ignore this
# then it will ask again.

def yesno(question)
    puts "#{question} [y/n]"
    loop do
        begin
                system("stty raw -echo")
                str = STDIN.getc
        ensure
                system("stty -raw echo")
        end

        if str == "Y" || str == "y"
            return true
        elsif str == "N" || str == "n"
            return false
        else
            puts "Please enter [y]es or [n]o."
        end
    end
end

##
# The main function.

def main()
	system("clear")

	userAgent = ""
	savedUAs = getUserAgents(REGEXDICTIONARY)
	if $opts[:choose_user_agent] then
		userAgent = askUAFromUser(savedUAs)
	else
		userAgent = $opts[:user_agent]
		if not doesUAexist(savedUAs, userAgent) then
			yes = yesno("It seems that the user agent you choose does not exist in our list of user agents, do you want to save it?")
			if yes then
				savedUAs.push(userAgent)
				saveUserAgent(savedUAs, REGEXDICTIONARY)
				puts "Saved!"
			end

		end
	end

    puts "Will match #{$opts[:regex]} in #{$opts[:link]}..."
    results = link_sherlock($opts[:link], $opts[:regex], userAgent,
                            $opts[:extensions].join("|"))

    if $opts[:downl_mode] then
        downl_all(results, $opts[:destination], $opts[:user_agent],
                  $opts[:overwrite])

    elsif !$opts[:downl_mode] then
        if results.count > 0 then 
            results.each do |link|
                    puts "#{link}"
            end

            download = yesno("Do you want to download these files to"\
                    " #{$opts[:destination]}?")

            if download then
                downl_all(results, $opts[:destination], $opts[:user_agent],
                        $opts[:overwrite])
            end
        end
    end
end

main()