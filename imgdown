#!/usr/bin/env ruby
# encoding: utf-8

"""""""
ImgDown
=======
ImgDown is used as image extractor to recursively download matched pattern.
The pattern is a regular expression. 

See https://en.wikipedia.org/wiki/Regular_expression for reference.

Usage:
./imgdown --download --link 'http://foo/bar' --regex '.*catpics\.jpe?g'
"""""""

IMGDOWN_VERSION = "v0.2.2"

require 'curb'
require 'uri'
require 'open-uri'
require 'nokogiri'
require 'trollop'
require 'fileutils'

$opts = Trollop::options do
	version IMGDOWN_VERSION
	banner <<-EOS
ImgDown is used as image extractor to recursively download matched pattern.
The pattern is a regular expression. 

See https://en.wikipedia.org/wiki/Regular_expression for reference.

Example:
./imgdown --download --link 'http://foo/bar' --regex '.*catpics\.jpe?g'

Usage:
./imgdown [options]

Where the options can be the following flags.
EOS
	
	opt :download, "This trigger the download sequence.", :short => 'd', :default => false
	opt :regex, "Use this tag to define a regular expression.", :short => 'r', :type => String, :default => "(.*)" # TODO: How does the regex for this program work.
	opt :link, "Link to the page that you want to download images from.", :short => 'l', :type => String
	opt :destination, "This defines the folder you want to download images to.", :short => 't', :type => String, :default => Dir.pwd
	opt :user_agent, "Use this tag if you want to specify a user-agent.", :short => 's', :type => String, :default => "ImgDown #{IMGDOWN_VERSION}"
    	opt :overwrite, "If you want to overwrite existing files with the same name", :short => 'i', :default => false
	opt :extensions, "The fileextensions imgdown will looking for", :short => 'x', :type => :strings, :default => ["jpe?g","png","gif"]
end

Trollop::die :link, "must exist" if $opts[:link] == "" || $opts[:link] == nil

# extractFilename(url)
# --------------------
# Extracting filenames
#
# Example:
# http://foo/bar/lols.img => lols.img
# /foo/bar/lols.img => lols.img

def extractFilename(url)
	url =~ /^.*\/(.*)\.(.*)$/
	if url == "" or url == nil then
		return ""
	else
		return "#{$1}.#{$2}"
	end
end

# getHostname(uri)
# ----------------
#
# Extracting hostname from a URI. See
# https://en.wikipedia.org/wiki/Uniform_resource_identifier
#
# Example:
# http://foo.com/bar -> http://foo.com
# https://www.alice.foo/bar -> https://www.alice.foo

def getHostname(uri)
	uri =~ /^(https?:\/\/([a-zA-Z0-9]+\.)+[a-zA-Z0-9]+)(\/.*)?$/
	return "#{$1}"
end

# doublet?(file, dir)
# -------------------
#
# Checking if a file exists in a directory.
#
# Example:
# The Tree
# /
# |--foo1
# |---|---bar1
# |---|---bar2
# |--foo2
# |---|---bar1
# |---|---bar2
# 
# ("bar1", "/foo1") => true
# ("bar1", "/foo2") => true
# ("bar3", "/foo1") => false
""
def doublet?(file, dir)
        return File.exists?("#{dir}/#{file}")
end

# link_sherlock(url, regexp, user_agent, fileExt)
# -----------------------------------------------
# This function searchs a HTML documents after images-urls
# and links that matches specified regular expression and 
# file extension.

def link_sherlock(url, regexp, user_agent, fileExt)
	_nokogiri_html_img = Nokogiri::HTML(
            open(url, 'User-Agent' => user_agent)).xpath('.//img/@src').to_a
	_nokogiri_html_a = Nokogiri::HTML(
            open(url,'User-Agent' => user_agent)).xpath('.//a/@href').to_a
	
	_links_array = _nokogiri_html_img + _nokogiri_html_a
	
	_m_links = []
	
	# Fixing links
	_links_array.each do |link|
		if "#{link}" =~ /#{regexp}/
			case link
			# /foo/bar/img
			when /^\/[^\/].*\.(#{fileExt})$/
				_m_links.push("#{getHostname(url)}#{link}")
			# https?://foo.bar [..] .fileext
			when /^https?:\/\/.*\.(#{fileExt})$/
				_m_links.push("#{link}")
			# abcd01234/foo [..] .fileext
			when /^[a-zA-Z0-9]+.*\.(#{fileExt})$/
				_m_links.push("#{getHostname(url)}/#{link}")
			when /^\/\/http:\/\/(.*\.(#{fileExt}))$/
				_m_links.push("http://#{$1}")
			when /^\/\/(?!https?)(.*\.(#{fileExt}))$/
				_m_links.push("http://#{$1}")
			end
		end
	end
	
	# No matches.
	if _m_links.count == 0
		puts "Zero matches."
	end

	# Return matches.
	return _m_links.uniq
end

# downl_f(file_uri, downl_path, user_agent)
# -----------------------------------------
# Downloads specified file to downl_path. User-agent must be specified.

def downl_f(file_uri, downl_path, user_agent)
	uri = URI(URI.parse(URI.encode(file_uri)))
	puts "Downloading #{file_uri} to #{downl_path}/#{extractFilename(file_uri)}..."
	_file_h = open("#{downl_path}/#{extractFilename(file_uri)}", "wb")
	curl = Curl::Easy.new(uri.to_s)
	curl.perform
	_file_h.write(curl.body_str)
	_file_h.close

end


# downl_all(array_w_links, dwl_path, user_agent, ow)
# --------------------------------------------------
# This function will download multiple files specified in a array of links.
# It will be downloaded to dwl_path and user-agent must be specifed. That
# includes if it should overwrite or not.

def downl_all(array_w_links, dwl_path, user_agent, overwrite)
    # There should be a check whether the directory exist or not. TODO
    if not File.directory?(dwl_path) then
        puts "Path is not valid! Trying to create the path."
        FileUtils::mkdir_p dwl_path
    end
    
    if overwrite then
            puts "Overwrite mode is on, ImgDown will overwrite existing files"
    end
    
    array_w_links.each do |url|
            doublet_exist = doublet?(extractFilename(url), dwl_path)
            if overwrite or !doublet_exist then
                    downl_f(url, dwl_path, user_agent)
            elsif doublet_exist then
                    if yesno("There was already an "\
                                "'#{extractFilename(url)}' "\
                                " in the directory!\n Continue?") then 
                            downl_f(url, dwl_path, user_agent)
                    else
                            puts "Quiting."
                            exit
                    end
            end
    end
end

# yesno(question)
# ---------------
# Will ask the user yes or no with a specified question. If user ignore this
# then it will ask again.

def yesno(question)
    puts "#{question} [y/n]"
    loop do
        begin
                system("stty raw -echo")
                str = STDIN.getc
        ensure
                system("stty -raw echo")
        end

        if str == "Y" || str == "y"
            return true
        elsif str == "N" || str == "n"
            return false
        else
            puts "Please enter [y]es or [n]o."
        end
    end
end

# main()
# ------
# The main function.

def main()
    puts "Will match #{$opts[:regex]} in #{$opts[:link]}..."
    results = link_sherlock($opts[:link], $opts[:regex], $opts[:user_agent],
                            $opts[:extensions].join("|"))

    if $opts[:downl_mode] then
        downl_all(results, $opts[:destination], $opts[:user_agent],
                  $opts[:overwrite])

    elsif !$opts[:downl_mode] then
        if results.count > 0 then 
            results.each do |link|
                    puts "#{link}"
            end

            download = yesno("Do you want to download these files to"\
                    " #{$opts[:destination]}?")

            if download then
                downl_all(results, $opts[:destination], $opts[:user_agent],
                        $opts[:overwrite])
            end
        end
    end
end

main()
